#include <iostream>
#include <random>
#include <stdlib.h>
#include <ctime>
using namespace std;
//define face cards
#define JACK    11
#define QUEEN   12
#define KING    13
#define ACE     1
//define suits
#define HEARTS 'h'
#define SPADES 's'
#define DIAMONDS 'd'
#define CLUBS 'c'
class Deck{
protected:
    //our deck and players hands will be a linked list
    class cardNode{//card has a number and suit
    public:
        cardNode(int n, char s):number(n), suit(s), next(nullptr){}
        int number;
        char suit;
        cardNode* next;
    };
    cardNode *head;
    cardNode *tail;
public:
    //default constructor
    Deck(){
        head = nullptr;
        tail = nullptr;
    }
    //destructor
    ~Deck(){
        while(!empty()){
            //remove card from head only if not an empty list
            if (head == nullptr){//empty list
                //do nothing
            }else{//not empty list
                cardNode *tmp = head;
                head = head ->next;
                if(head == nullptr)//now an empty list
                    tail = nullptr;
                delete tmp;
            }
        }
    }
    //copy constructor
    Deck(const Deck& other){
        head = nullptr;
        tail = nullptr;
        cardNode * tmp = other.head;
        while(tmp){
            insertCard(tmp->number, tmp->suit);
            tmp = tmp->next;
        }
    }
    //copy assignment operator
    Deck& operator=(const Deck &other){
        //if assigning to the same object do nothing
        if(this == &other){
            return *this;
        }
        head = nullptr;
        tail = nullptr;
        cardNode * tmp = other.head;
        while(tmp){
            insertCard(tmp->number, tmp->suit);
            tmp = tmp->next;
        }
        return *this;
    }
    //***Function to create a standard deck of 52 cards in random order
    void createDeck()
    {
        while (!empty()) //clear old game deck if playing a new game
        {
            if (head != NULL)
            {
                cardNode* tmp = head;
                head = head->next;
                if (head == NULL)
                    tail = NULL;
                delete tmp;
            }
        }
        for (int i = 0; i < 4; i++)
        {
            for (int j = 1; j < 14; j++)
            {
                if (i == 0)
                    insertCard(j, HEARTS);
                if (i == 1)
                    insertCard(j, SPADES);
                if (i == 2)
                    insertCard(j, DIAMONDS);
                if (i == 3)
                    insertCard(j, CLUBS);
            }
        }
        //randomize list
        //use random number generator to get random "index"
        srand(time(nullptr));
        //remove node and insert
        for(int i=0; i<100;i++){
            int randomIndex = rand() % 51;
            cardNode *tmp = this->head;
            cardNode * previous = nullptr;
            for(int i = 0; i< randomIndex; i++){
                //increment tmp and previous
                previous = tmp;
                tmp = tmp->next;
            }
            //delete node
            if(tmp == head) {//remove head
                if (tmp == tail) {//removing last node in the list
                    head = tail = nullptr;
                }else{
                    head = tmp->next;
                }
            }else if(tmp == tail){//remove tail
                tail = previous;
                tail->next = nullptr;
            }else{//remove middle
                previous->next = tmp->next;
            }
            //insert the removed node in beginning of list
            insertCard(tmp->number, tmp->suit);
            delete tmp;
            previous = nullptr;
            delete previous;
        }
    }
    //deck only has to insert at the tail
    void insertCard(int value, char suit){
        cardNode * newCard = new cardNode(value, suit);
        if(head == nullptr){//empty deck
        head = tail = newCard;
        }else{//not empty deck
            //only need to append at the end of the deck
            tail->next = newCard;
            tail = newCard;
        }
    }
    //deck only has to remove from the head since players draw from top
    //but playerHands can remove from anywhere in the players group of cards
    // so removeCard will have to be overridden. This is why we are making
    // removeCard virtual.
    virtual bool removeCard() {
        //remove card from head only if not an empty list
        if (head == nullptr){//empty list
            //do nothing
            return false;//can't remove, empty deck
        }else{//not empty list
            cardNode *tmp = head;
            head = tmp ->next;
            tmp->next = nullptr;
            delete tmp;
            if(head == nullptr)//now an empty list
                tail = nullptr;

            return true;//was able to remove
        }
    }
    //need a peek function to know what the values of the card on the top are
    cardNode* peek(){//cant call peek on empty list
        //head is always at the top of the deck
        return head;
    }
    bool empty(){
        return this->head == nullptr;
    }
    void printList(){
        cardNode * tmp = head;
        while(tmp){
            cout << tmp->number << tmp->suit << ", " ;
            tmp = tmp->next;
        }
        cout << endl;
    }

};

class playerHands: public Deck {
protected:
public:
    //default constructor
    playerHands(){
    head = nullptr;
    tail = nullptr;
    }

    //can use inherited insert

    //insert seven cards from deck into player hands
    void deal(Deck &globalDeck) {
        for(int i = 0; i < 7; i++){//insert seven times from deck
            int value = globalDeck.peek()->number;
            char suit = globalDeck.peek()->suit;
            //insert drawn card into player hands
            this->insertCard(value, suit);
            //remove drawn card from deck
            globalDeck.removeCard();
        }
    }
    //draw one card from deck, print value drawn
    bool draw(Deck &globalDeck) {
        //check if empty deck
        if(globalDeck.peek() == nullptr){
            cout << "empty deck" << endl;
            return false;
        }else{//not empty deck
            //create new card node to insert into players hands
            int value = globalDeck.peek()->number;
            char suit = globalDeck.peek()->suit;
            //insert drawn card into player hands
            this->insertCard(value, suit);
            //remove drawn card from deck
            globalDeck.removeCard();
            return true;
        }
    }
    
    //need to find Card from each players hand
    //find function only looks at number value and not suit since
    //number value is what creates a match in GoFish
    bool find(int valueToFind) {
        //start iterating at beginning of players list
        cardNode * tmp = this->head;
        while(tmp->next != nullptr){
            if(tmp->number == valueToFind){
                //return true if found
                delete tmp;
                return true;
            }
            tmp = tmp->next;
        }
        //return false if not found
        return false;
    }

    //need to override inherited remove
    bool remove(int valueToRemove, char suitToRemove){
        //can remove from anywhere in linked list
        cardNode *tmp = this->head;
        cardNode * previous = nullptr;
        while(tmp->next != nullptr){//loop through list until node is found
            if((tmp->number == valueToRemove) &&
            (tmp->suit == suitToRemove)){
                //card found now remove it

                if(tmp == head) {//remove head
                    if (tmp == tail) {//removing last node in the list
                        head = tail = nullptr;
                    }else{
                        head = tmp->next;
                    }
                }else if(tmp == tail){//remove tail
                    tail = previous;
                    tail->next = nullptr;
                }else{//remove middle
                    previous->next = tmp->next;
                }
                delete tmp;
                return true;
            }
            //increment tmp and previous
            previous = tmp;
            tmp = tmp->next;
        }
        //delete nodes created
        delete tmp;
        previous = nullptr;
        delete previous;
        //return false if not found
        return false;
    }
};
int main() {
    Deck gameDeck;
    gameDeck.createDeck();
    cout << "deck: ";
    gameDeck.printList();


    return 0;
}
